diff -urN a/cryst/Changelog b/cryst/Changelog
--- a/cryst/Changelog	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/Changelog	2018-11-01 18:56:12.000000000 -0400
@@ -1,5 +1,89 @@
+Version 4.1.18
 
-Version 4.0: Initial release for GAP 4.
+  - Fixed trivial changes in output of a manual example and several test examples.
+
+Version 4.1.17
+
+  - Bug in ConjugatorSpaceGroups fixed.
+
+Version 4.1.16
+
+  - Bug in ImagesRepresentative for isomorphism to PcpGroup fixed.
+  - Bug in kernel of PointHomomorphism for left-acting group fixed.
+  - Bugs in Centralizer and CanonicalRightCosetElement fixed.
+  - Test files with better code coverage.
+
+Version 4.1.15
+
+  - PackageInfo record corrected
+
+Version 4.1.14
+
+  - Corrected incompatible standardizations of affine subspaces.
+  - Added various testfiles.
+
+Version 4.1.13
+
+  - Fixed a bug in ImagesRepresentative for IsFromAffineCrystGroupToPcpGroup
+
+Version 4.1.12
+
+  - Fixed a bug in RepresentativeAction for AffineCrystGroups
+
+Version 4.1.11
+
+  - Fixed a bug in the conjugation of left-acting AffineCrystGroups
+  - Changed outdated RequirePackage in manual
+
+Version 4.1.10
+
+  - Fixed file permission problem
+
+Version 4.1.9
+
+  - Minor Update
+
+Version 4.1.8
+
+  - Bugfix in AffineNormalizer
+
+Version 4.1.7
+
+  - Adapted to GAP 4.5
+
+Version 4.1.6
+
+  - TranslationBasis for trivial point group fixed
+  - Bug in ImagesRepresentative for IsomorphismFpGroup of an
+    AffineCrystGroupOnLeft fixed
+  - Multiplication with empty matrix in WyckoffPositions fixed
+  - Membership test in AffineCrystGroups improved
+
+Version 4.1.5
+
+  - Incomplete translation basis fixed
+
+Version 4.1.4
+
+  - Two instances of multiplying an empty list with a matrix fixed
+
+Version 4.1.3:
+
+  - Mutability problem fixed
+
+Version 4.1.2:
+
+  - File manual.toc added
+
+Version 4.1.1:
+
+  - Online help should now work for all functions.
+
+  - Fixed several manual examples changed output or wrong input.
+
+  - Avoided some multiplications of an empty list with a matrix.
+
+  - Support for new package loading mechanism in GAP 4.4
 
 Version 4.1:
 
@@ -48,62 +132,4 @@
 
   - A mutability bug in AffineNormalizer was fixed.
 
-Version 4.1.1:
-
-  - Online help should now work for all functions.
-
-  - Fixed several manual examples changed output or wrong input.
-
-  - Avoided some multiplications of an empty list with a matrix.
-
-  - Support for new package loading mechanism in GAP 4.4
-
-Version 4.1.2:
-
-  - File manual.toc added
-
-Version 4.1.3:
-
-  - Mutability problem fixed
-
-Version 4.1.4
-
-  - Two instances of multiplying an empty list with a matrix fixed
-
-Version 4.1.5
-
-  - Incomplete translation basis fixed
-
-Version 4.1.6
-
-  - TranslationBasis for trivial point group fixed
-  - Bug in ImagesRepresentative for IsomorphismFpGroup of an
-    AffineCrystGroupOnLeft fixed
-  - Multiplication with empty matrix in WyckoffPositions fixed
-  - Membership test in AffineCrystGroups improved
-
-Version 4.1.7
-
-  - Adapted to GAP 4.5
-
-Version 4.1.8
-
-  - Bugfix in AffineNormalizer
-
-Version 4.1.9
-
-  - Minor Update
-
-Version 4.1.10
-
-  - Fixed file permission problem
-
-Version 4.1.11
-
-  - Fixed a bug in the conjugation of left-acting AffineCrystGroups
-  - Changed outdated RequirePackage in manual
-
-Version 4.1.12
-
-  - Fixed a bug in RepresentativeAction for AffineCrystGroups
-
+Version 4.0: Initial release for GAP 4.
diff -urN a/cryst/doc/cryst.tex b/cryst/doc/cryst.tex
--- a/cryst/doc/cryst.tex	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/doc/cryst.tex	2018-11-01 18:56:12.000000000 -0400
@@ -836,7 +836,7 @@
 \Section{Colored AffineCrystGroups}
 
 If <C> is a colored `AffineCrystGroup' whose `ColorSubgroup' is 
-lattice-equal (translationengleich) with <C>, the `PointGroup' of 
+lattice-equal (translationengleich) with <C>, then the `PointGroup' of 
 <C> can consistently be colored. In that case,
 
 \>PointGroup( C )!{for a colored `AffineCrystGroup'} A
@@ -868,12 +868,14 @@
 gap> sub := MaximalSubgroupClassReps( S, rec( primes := [2] ) );
 [ <matrix group with 4 generators>, <matrix group with 3 generators>, 
   <matrix group with 4 generators> ]
+gap> List( sub, Size );
+[ infinity, infinity, infinity ]
 gap> sub := Filtered( sub, s -> IndexInParent( s ) = 2 );
-[ <matrix group with 4 generators>, <matrix group with 3 generators>, 
-  <matrix group with 4 generators> ]
-gap> sub := AffineInequivalentSubgroups( S, sub );
 [ <matrix group of size infinity with 4 generators>, 
-  <matrix group of size infinity with 3 generators> ]
+  <matrix group of size infinity with 3 generators>, 
+  <matrix group of size infinity with 4 generators> ]
+gap> Length( AffineInequivalentSubgroups( S, sub ) );
+2
 \endexample
 
 Note that `AffineInequivalentSubgroups' requires the {\GAP} package 
diff -urN a/cryst/doc/make_doc b/cryst/doc/make_doc
--- a/cryst/doc/make_doc	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/doc/make_doc	2018-11-01 18:56:12.000000000 -0400
@@ -3,6 +3,7 @@
 tex manual
 ../../../doc/manualindex manual
 tex manual
+mkdir -p ../htm
 ../../../etc/convert.pl -c -i -u -n cryst . ../htm
 dvips -o manual.ps manual
 ps2pdf manual.ps manual.pdf
Binary files a/cryst/doc/manual.pdf and b/cryst/doc/manual.pdf differ
diff -urN a/cryst/doc/manual.tex b/cryst/doc/manual.tex
--- a/cryst/doc/manual.tex	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/doc/manual.tex	2018-11-01 18:56:12.000000000 -0400
@@ -19,7 +19,7 @@
   \medskip
   \centerline{\subtitlefont A GAP4 Package}
   \bigskip\medskip
-  \centerline{\secfont Version 4.1.12}
+  \centerline{\secfont Version 4.1.18}
   \bigskip\medskip
   \vfill
 
@@ -61,7 +61,7 @@
   \centerline{\secfont{\Month} \Year}
 
   \vfill
-  \centerline{Copyright {\copyright} 1999--2013 by 
+  \centerline{Copyright {\copyright} 1999--2018 by 
               Bettina Eick, Franz G{\accent127 a}hler, and Werner Nickel}
 
   \bigskip
diff -urN a/cryst/gap/cryst2.gi b/cryst/gap/cryst2.gi
--- a/cryst/gap/cryst2.gi	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/cryst2.gi	2018-11-01 18:56:12.000000000 -0400
@@ -304,6 +304,7 @@
 
     mm  := CanonicalRightCosetElement( P, m );
     res := PreImagesRepresentative( PointHomomorphism( S ), mm*m^-1 ) * rep;
+    res := MutableCopyMat( res );
     res[d+1]{[1..d]} := VectorModL( res[d+1]{[1..d]}, T );
     return res;
 
@@ -322,6 +323,7 @@
 
     mm  := CanonicalRightCosetElement( P, m );
     res := PreImagesRepresentative( PointHomomorphism( S ), mm*m^-1 ) * rep;
+    res := MutableCopyMat( res );
     res{[1..d]}[d+1] := VectorModL( res{[1..d]}[d+1], T );
     return res;
 
@@ -518,7 +520,9 @@
             L{[1..e]}{[1..d]+(i-1)*d} := T*(gen[i]-I);
         od;
         P := Centralizer( P, M );
-        P := Stabilizer( P, TranslationBasis( obj ), OnRight );
+        if not IsEmpty( TranslationBasis( obj ) ) then
+            P := Stabilizer( P, TranslationBasis( obj ), OnRight );
+        fi;
         U := Filtered( GeneratorsOfGroup(obj), x -> x{[1..d]}{[1..d]} <> I );
     else
         if not IsAffineMatrixOnRight( obj ) then
diff -urN a/cryst/gap/equiv.gi b/cryst/gap/equiv.gi
--- a/cryst/gap/equiv.gi	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/equiv.gi	2018-11-01 18:56:12.000000000 -0400
@@ -17,7 +17,7 @@
 ConjugatorSpaceGroupsStdSamePG := function( S1, S2 )
 
     local P, d, M, I, g, i, gen1, t1, gen2, t2, sol, Ngen, 
-          orb, img, gen, rep, nn;
+          orb, img, S, rep, nn, n1;
 
     P := PointGroup( S1 );
     d := DimensionOfMatrixGroup( P ); 
@@ -46,25 +46,25 @@
     fi;
 
     # if we arrive here, we need the normalizer
-#    Print("#I need normalizer\n");
     Ngen := GeneratorsOfGroup( NormalizerPointGroupInGLnZ( P ) );
-    Ngen := Filtered( Ngen, x -> not x in P );
-
-    orb := [ GeneratorsOfGroup( P) ];
-    rep := [ One( P ) ];
-    for gen in orb do
+    Ngen := List( Filtered( Ngen, x -> not x in P ),
+                  y -> AugmentedMatrix( y, 0*[1..d] ) );
+    orb := [ S1 ];
+    rep := [ One( S1 ) ];
+    for S in orb do
         for g in Ngen do
-            img := List( gen, x -> x^g );
+            img := S^g;
             if not img in orb then
-                nn   := rep[Position(orb,gen)]*g;
+                nn   := rep[Position(orb,S)]*g;
                 Add( orb, img );
                 Add( rep, nn  );
-                gen2 := List( img, x -> PreImagesRepresentative( 
-                                        PointHomomorphism( S2 ), x ) );
-                t2 := Concatenation( List( gen2, x -> x[d+1]{[1..d]}*nn^-1));
+                gen1 := List( GeneratorsOfGroup( P ),
+                  x -> PreImagesRepresentative( PointHomomorphism( img ), x ) );
+                n1 := nn{[1..d]}{[1..d]};
+                t1 := Concatenation( List( gen1, x -> x[d+1]{[1..d]}));
                 sol  := SolveInhomEquationsModZ( M, t1-t2, true )[1];
                 if sol <> [] then
-                    return AugmentedMatrix( nn, sol[1]*nn );
+                    return AugmentedMatrix( n1, sol[1] );
                 fi;
             fi;
         od;
@@ -81,13 +81,30 @@
       IsAffineCrystGroupOnRight and IsSpaceGroup ], 0,
 function( S1, S2 )
 
-    local d, C1, C2, C3, C4, c, S1std, S2std, P1std, P2std, S3;
+    local d, P1, P2, ls1, ls2, C1, C2, C3, C4, c,
+          S1std, S2std, P1std, P2std, S3;
 
     d := DimensionOfMatrixGroup( S1 ) - 1;    
 
+    # some short cuts
+    P1 := PointGroup( S1 );
+    P2 := PointGroup( S2 );
+    if Size( P1 ) <> Size( P2 ) then
+        return fail;
+    fi;
+    ls1 := AsSortedList( List( ConjugacyClasses( P1 ),
+             x -> [ Size(x), TraceMat( Representative(x) ),
+                    DeterminantMat( Representative(x) ) ] ) );
+    ls2 := AsSortedList( List( ConjugacyClasses( P2 ),
+             x -> [ Size(x), TraceMat( Representative(x) ),
+                    DeterminantMat( Representative(x) ) ] ) );
+    if ls1 <> ls2 then
+        return fail;
+    fi;
+
     # go to standard representation
 
-    # S1^C1 = S1std
+    # S1 = S1std^C1
     if IsStandardSpaceGroup( S1 ) then
         S1std := S1;
         C1    := IdentityMat( d+1 );
@@ -96,7 +113,7 @@
         C1    := AugmentedMatrix( InternalBasis( S1 ), 0*[1..d] );
     fi;
 
-    # S2^C2 = S2std
+    # S2 = S2std^C2
     if IsStandardSpaceGroup( S2 ) then
         S2std := S2;
         C2    := IdentityMat( d+1 );
@@ -108,7 +125,6 @@
     P1std := PointGroup( S1std );
     P2std := PointGroup( S2std );
 
-    d := DimensionOfMatrixGroup( P1std );    
     if P1std = P2std then
         C3 := IdentityMat( d+1 );
         S3 := S2std;
diff -urN a/cryst/gap/hom.gd b/cryst/gap/hom.gd
--- a/cryst/gap/hom.gd	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/hom.gd	2018-11-01 18:56:12.000000000 -0400
@@ -37,13 +37,3 @@
 ##
 DeclareProperty( "IsFromAffineCrystGroupToPcpGroup", 
                                              IsGroupGeneralMappingByImages );
-
-#############################################################################
-##
-#A  MappingGeneratorsImages - for compatibility with GAP 4.2 and GAP 4.1
-##
-if not CompareVersionNumbers( VERSION, "4.3" ) then
-    if not IsBound( MappingGeneratorsImages ) then
-        DeclareAttribute( "MappingGeneratorsImages", IsGeneralMapping );
-    fi;
-fi;
diff -urN a/cryst/gap/hom.gi b/cryst/gap/hom.gi
--- a/cryst/gap/hom.gi	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/hom.gi	2018-11-01 18:56:12.000000000 -0400
@@ -61,6 +61,9 @@
         m[d+1]{[1..d]} := t;
         Add( gens, m );
     od;
+    if IsAffineCrystGroupOnLeft( S ) then
+        gens := List( gens, TransposedMat );
+    fi;
     return SubgroupNC( S, gens );
 
 end );
diff -urN a/cryst/gap/max.gi b/cryst/gap/max.gi
--- a/cryst/gap/max.gi	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/max.gi	2018-11-01 18:56:12.000000000 -0400
@@ -572,7 +572,8 @@
 
     pres  := Image( iso );
     rep   := List( Ggens, x -> x{[1..n]}{[1..n]} );
-    coc   := CocycleInfo( G ) * T^-1;
+    coc   := CocycleInfo( G );
+    if not IsEmpty( coc ) then coc := coc * T^-1; fi;
     d     := DimensionOfMatrixGroup( G ) - 1;
     trans := List( T, x -> IdentityMat( d+1 ) );
     for i in [1..n] do
diff -urN a/cryst/gap/pcpgrp.gi b/cryst/gap/pcpgrp.gi
--- a/cryst/gap/pcpgrp.gi	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/pcpgrp.gi	2018-11-01 18:56:12.000000000 -0400
@@ -149,30 +149,56 @@
 InstallMethod( ImagesRepresentative, FamSourceEqFamElm,
     [IsGroupGeneralMappingByImages and IsFromAffineCrystGroupToPcpGroup,
      IsMultiplicativeElementWithInverse ], 0,
-function( iso, elm )
-
-    local d, S, T, elmP, isoP, exp, genS, elm2, v;
-
-    d := Length( elm ) - 1;
-    S := Source( iso );
-    T := TranslationBasis( S );
-
-    elmP := elm{[1..d]}{[1..d]};
-    isoP := IsomorphismPcpGroup( PointGroup( S ) );
-    exp  := Exponents( ImagesRepresentative( isoP, elmP ) );
-
-    genS := MappingGeneratorsImages( iso )[1];
-    elm2 := MappedVector( exp, genS{[1..Length(exp)]} );
+function(iso, elm)
+    local d, S, T, P, m, l, w, N, F, gensF, gensN, matsP, e, f, g, exp,
+          new, rem, v, s, H, h, p;
+
+    # set up dim and space group
+    d := Length(elm)-1;
+    S := Source(iso);
+    T := TranslationBasis(S);
+
+    # set up point group
+    P := PointGroup(S);
+    m := NiceMonomorphism(P);    # P -> N
+    N := Image(m);
+    l := NiceToCryst(P);         # N -> S
+    w := IsomorphismPcpGroup(N); # N -> Pcp
+
+    # get preimages
+    F := Image(w);
+    gensF := Cgs(F);
+    gensN := List(gensF, x -> PreImagesRepresentative(w, x));
+    matsP := List(gensN, x -> ImagesRepresentative(l, x));
+    
+    # point group part
+    e := elm{[1..d]}{[1..d]};
+    f := Image(m, e);
+    g := Image(w, f);
+    exp := Exponents(g);
+    
+    # divide off
+    new := MappedVector( exp, matsP );
+    rem := new^-1 * elm;
     if Length( T ) > 0 then
         if IsAffineCrystGroupOnRight( S ) then
-            v := elm[d+1]{[1..d]} - elm2[d+1]{[1..d]};
+            v := rem[d+1]{[1..d]};
         else
-            v := elm{[1..d]}[d+1] - elm2{[1..d]}[d+1];
+            v := rem{[1..d]}[d+1];
         fi;
-        exp := Concatenation( exp, SolutionMat( T, v ) );
+        s := SolutionMat(T, v);
+        exp := Concatenation( exp, s );
     fi;
-    return PcpElementByExponents( Collector( One( Range( iso ) ) ), exp );
 
+    # translate
+    H := Image(iso);
+    h := Cgs(H);
+
+    # do some check
+    p := List(h, x -> PreImagesRepresentative(iso,x));
+    if MappedVector(exp, p) <> elm then Error("hier"); fi;
+
+    return MappedVector(exp, h);
 end );
 
 #############################################################################
diff -urN a/cryst/gap/wyckoff.gi b/cryst/gap/wyckoff.gi
--- a/cryst/gap/wyckoff.gi	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/gap/wyckoff.gi	2018-11-01 18:56:12.000000000 -0400
@@ -103,6 +103,7 @@
         if not IsStandardAffineCrystGroup( r.spaceGroup ) then
             v := v * T;
         fi;
+        v := VectorModL( r.translation, T );
     else
         v := VectorModL( r.translation, T );
     fi;
diff -urN a/cryst/htm/biblio.htm b/cryst/htm/biblio.htm
--- a/cryst/htm/biblio.htm	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/htm/biblio.htm	2018-11-01 18:56:12.000000000 -0400
@@ -28,5 +28,5 @@
 </dl><p>
 [<a href="chapters.htm">Up</a>]<p>
 <P>
-<address>cryst manual<br>October 2013
+<address>cryst manual<br>Oktober 2018
 </address></body></html>
diff -urN a/cryst/htm/CHAP000.htm b/cryst/htm/CHAP000.htm
--- a/cryst/htm/CHAP000.htm	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/htm/CHAP000.htm	1969-12-31 19:00:00.000000000 -0500
@@ -1,3 +0,0 @@
-<html><head><title>[cryst]  </title></head>
-<body text="#000000" bgcolor="#ffffff">
-[<a href = "chapters.htm">Up</a>] 
\ No newline at end of file
diff -urN a/cryst/htm/CHAP001.htm b/cryst/htm/CHAP001.htm
--- a/cryst/htm/CHAP001.htm	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/htm/CHAP001.htm	2018-11-01 18:56:12.000000000 -0400
@@ -65,5 +65,5 @@
 <p>
 [<a href = "chapters.htm">Up</a>] [<a href ="CHAP002.htm">Next</a>] [<a href = "theindex.htm">Index</a>]
 <P>
-<address>cryst manual<br>October 2013
+<address>cryst manual<br>Oktober 2018
 </address></body></html>
\ No newline at end of file
diff -urN a/cryst/htm/CHAP002.htm b/cryst/htm/CHAP002.htm
--- a/cryst/htm/CHAP002.htm	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/htm/CHAP002.htm	2018-11-01 18:56:12.000000000 -0400
@@ -895,7 +895,7 @@
 <h2><a name="SECT010">2.10 Colored AffineCrystGroups</a></h2>
 <p><p>
 If <var>C</var> is a colored <code>AffineCrystGroup</code> whose <code>ColorSubgroup</code> is 
-lattice-equal (translationengleich) with <var>C</var>, the <code>PointGroup</code> of 
+lattice-equal (translationengleich) with <var>C</var>, then the <code>PointGroup</code> of 
 <var>C</var> can consistently be colored. In that case,
 <p>
 <a name = "SSEC010.1"></a>
@@ -929,12 +929,14 @@
 gap&gt; sub := MaximalSubgroupClassReps( S, rec( primes := [2] ) );
 [ &lt;matrix group with 4 generators&gt;, &lt;matrix group with 3 generators&gt;, 
   &lt;matrix group with 4 generators&gt; ]
+gap&gt; List( sub, Size );
+[ infinity, infinity, infinity ]
 gap&gt; sub := Filtered( sub, s -&gt; IndexInParent( s ) = 2 );
-[ &lt;matrix group with 4 generators&gt;, &lt;matrix group with 3 generators&gt;, 
-  &lt;matrix group with 4 generators&gt; ]
-gap&gt; sub := AffineInequivalentSubgroups( S, sub );
 [ &lt;matrix group of size infinity with 4 generators&gt;, 
-  &lt;matrix group of size infinity with 3 generators&gt; ]
+  &lt;matrix group of size infinity with 3 generators&gt;, 
+  &lt;matrix group of size infinity with 4 generators&gt; ]
+gap&gt; Length( AffineInequivalentSubgroups( S, sub ) );
+2
 </pre>
 <p>
 Note that <code>AffineInequivalentSubgroups</code> requires the <font face="Gill Sans,Helvetica,Arial">GAP</font> package 
@@ -1011,5 +1013,5 @@
 <p>
 [<a href = "chapters.htm">Up</a>] [<a href ="CHAP001.htm">Previous</a>] [<a href = "theindex.htm">Index</a>]
 <P>
-<address>cryst manual<br>October 2013
+<address>cryst manual<br>Oktober 2018
 </address></body></html>
\ No newline at end of file
diff -urN a/cryst/htm/chapters.htm b/cryst/htm/chapters.htm
--- a/cryst/htm/chapters.htm	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/htm/chapters.htm	2018-11-01 18:56:12.000000000 -0400
@@ -13,5 +13,5 @@
 <li><a href="theindex.htm">Index</a>
 </ul><p>
 <P>
-<address>cryst manual<br>October 2013
+<address>cryst manual<br>Oktober 2018
 </address></body></html>
\ No newline at end of file
diff -urN a/cryst/htm/theindex.htm b/cryst/htm/theindex.htm
--- a/cryst/htm/theindex.htm	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/htm/theindex.htm	2018-11-01 18:56:12.000000000 -0400
@@ -135,5 +135,5 @@
 </dl><p>
 [<a href="chapters.htm">Up</a>]<p>
 <P>
-<address>cryst manual<br>October 2013
+<address>cryst manual<br>Oktober 2018
 </address></body></html>
\ No newline at end of file
diff -urN a/cryst/PackageInfo.g b/cryst/PackageInfo.g
--- a/cryst/PackageInfo.g	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/PackageInfo.g	2018-11-01 18:56:12.000000000 -0400
@@ -9,13 +9,13 @@
 
 Subtitle := "Computing with crystallographic groups",
 
+Version := "4.1.18",
 
-Version := "4.1.12",
+# Format: dd/mm/yyyy
+Date := "23/10/2018",
 
-Date := "10/10/2013",
-
-ArchiveURL := 
-  "http://www.math.uni-bielefeld.de/~gaehler/gap45/Cryst/cryst-4.1.12",
+ArchiveURL := Concatenation( 
+  "https://www.math.uni-bielefeld.de/~gaehler/gap45/Cryst/cryst-", ~.Version ),
 
 ArchiveFormats := ".tar.gz",
 
@@ -39,7 +39,7 @@
     IsAuthor := true,
     IsMaintainer := true,
     Email := "gaehler@math.uni-bielefeld.de",
-    WWWHome := "http://www.math.uni-bielefeld.de/~gaehler/",
+    WWWHome := "https://www.math.uni-bielefeld.de/~gaehler/",
     #PostalAddress := "",           
     Place := "Bielefeld",
     Institution := "Mathematik, Universität Bielefeld"
@@ -64,9 +64,9 @@
 AcceptDate := "02/2000",
 
 README_URL := 
-  "http://www.math.uni-bielefeld.de/~gaehler/gap45/Cryst/README.cryst",
+  "https://www.math.uni-bielefeld.de/~gaehler/gap45/Cryst/README.cryst",
 PackageInfoURL := 
-  "http://www.math.uni-bielefeld.de/~gaehler/gap45/Cryst/PackageInfo.g",
+  "https://www.math.uni-bielefeld.de/~gaehler/gap45/Cryst/PackageInfo.g",
 
 AbstractHTML := 
 "This package, previously known as <span class=\"pkgname\">CrystGAP</span>, \
@@ -80,7 +80,14 @@
 functionality provided by the package <span class=\"pkgname\">Carat</span>.",
 
 PackageWWWHome := 
-  "http://www.math.uni-bielefeld.de/~gaehler/gap45/packages.php",
+  "https://www.math.uni-bielefeld.de/~gaehler/gap45/packages.php",
+
+SourceRepository := rec(
+  Type := "git",
+  URL := Concatenation( "https://github.com/gap-packages/",
+                        LowercaseString( ~.PackageName ) ) ),
+IssueTrackerURL := Concatenation( ~.SourceRepository.URL, "/issues" ),
+SupportEmail := "gaehler@math.uni-bielefeld.de",
 
 PackageDoc  := rec(
   BookName  := "Cryst",
@@ -106,7 +113,7 @@
 
 #BannerString := "",
 
-#TestFile := "tst/testall.g",
+TestFile := "tst/testall.g",
 
 Keywords := [ "crystallographic groups", 
               "affine crystallographic groups",
@@ -114,7 +121,7 @@
               "color groups",
               "point group",
               "Wyckoff positions",
-              "International Tables for Cystallography",
+              "International Tables for Crystallography",
               "maximal subgroups",
               "normalizer" ]
 ));
diff -urN a/cryst/README b/cryst/README
--- a/cryst/README	2016-11-12 09:25:17.000000000 -0500
+++ b/cryst/README	2018-11-01 18:56:12.000000000 -0400
@@ -1,4 +1,3 @@
-
 The GAP 4 package Cryst, previously known as CrystGap, is the 
 successor of the CrystGap package for GAP 3. During the porting 
 process to GAP 4, large parts of the code have been rewritten, and 
@@ -23,27 +22,29 @@
 Cryst is distributed with GAP, and does not require any installation.
 It is loaded with the GAP command
 
-gap> LoadPackage( "cryst" ); 
+    gap> LoadPackage( "cryst" ); 
 
 Cryst has been developed by
 
-Bettina Eick,
-Institut Computational Mathematics,
-Fachbereich Mathematik und Informatik,
-Technische Universit\"at Braunschweig,
-Pockelsstr. 14, D-38106 Braunschweig, Germany
-e-mail: beick@tu-bs.de
-
-Franz G\"ahler,
-Fakult\"at f\"ur Mathematik, Universit\"at Bielefeld,
-Postfach 10 01 31, D-33501 Bielefeld, Germany 
-e-mail: gaehler@math.uni-bielefeld.de
-
-Werner Nickel,
-Fachbereich Mathematik, AG2,
-Technische Universit\"at Darmstadt,
-Schlossgartenstrasse 7, D-64289 Darmstadt, Germany
-e-mail: nickel@mathematik.tu-darmstadt.de
+    Bettina Eick,
+    Institut Computational Mathematics,
+    Fachbereich Mathematik und Informatik,
+    Technische Universität Braunschweig,
+    Pockelsstr. 14, D-38106 Braunschweig, Germany
+    e-mail: beick@tu-bs.de
+
+    Franz Gähler,
+    Fakultät für Mathematik, Universität Bielefeld,
+    Postfach 10 01 31, D-33501 Bielefeld, Germany 
+    e-mail: gaehler@math.uni-bielefeld.de
+
+    Werner Nickel,
+    Fachbereich Mathematik, AG2,
+    Technische Universität Darmstadt,
+    Schlossgartenstrasse 7, D-64289 Darmstadt, Germany
+    e-mail: nickel@mathematik.tu-darmstadt.de
+
+For bug reports, suggestions and other comments please use the issue
+tracker on the GitHub page of the package:
 
-Please send bug reports, suggestions and other comments to any of these
-e-mail addresses.
+    https://github.com/gap-packages/cryst/issues
diff -urN a/cryst/tst/cryst.tst b/cryst/tst/cryst.tst
--- a/cryst/tst/cryst.tst	1969-12-31 19:00:00.000000000 -0500
+++ b/cryst/tst/cryst.tst	2018-11-01 18:56:12.000000000 -0400
@@ -0,0 +1,344 @@
+gap> START_TEST( "Cryst: cryst.tst" );
+
+gap> SetAssertionLevel(1);
+
+gap> C := SpaceGroupIT( 3, 133 );
+SpaceGroupOnRightIT(3,133,'2')
+
+gap> m := IdentityMat(4);
+[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]
+
+gap> C^m;
+<matrix group with 7 generators>
+
+gap> C := SpaceGroupIT( 3, 133 );
+SpaceGroupOnRightIT(3,133,'2')
+
+gap> P := PointGroup( C );
+<matrix group of size 16 with 4 generators>
+
+gap> NormalizerInGLnZ( P );
+<matrix group of size 16 with 7 generators>
+
+gap> S := SpaceGroupBBNWZ( 4, 29, 7, 2, 1 );
+SpaceGroupOnRightBBNWZ( 4, 29, 7, 2, 1 )
+
+gap> S := WyckoffStabilizer( WyckoffPositions(S)[1] );
+<matrix group with 4 generators>
+
+gap> cl := ConjugacyClasses( S );
+[ [ [ 1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], 
+      [ 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ -1, -1, -1, -1, 0 ], [ 0, 1, 0, 1, 0 ], [ 1, 1, 0, 0, 0 ], 
+      [ 0, -1, 0, 0, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ -1, -1, 0, 0, 0 ], [ 0, 0, -1, -1, 0 ], [ 1, 0, 0, 0, 0 ], 
+      [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ -1, -1, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 1, 1, 1, 1, 0 ], 
+      [ 0, -1, 0, -1, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ -1, -1, 0, 0, 0 ], [ 1, 0, 0, 0, 0 ], [ 0, 0, -1, -1, 0 ], 
+      [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ -1, 0, 0, 0, 0 ], [ 0, -1, 0, 0, 0 ], [ 1, 0, 1, 0, 0 ], 
+      [ 0, 1, 0, 1, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ 0, -1, 0, -1, 0 ], [ 0, 1, 0, 0, 0 ], [ 1, 1, 1, 1, 0 ], 
+      [ -1, -1, 0, 0, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ 0, -1, 0, -1, 0 ], [ 1, 1, 1, 1, 0 ], [ 0, 1, 0, 0, 0 ], 
+      [ -1, -1, 0, 0, 0 ], [ 0, 0, 0, 0, 1 ] ]^G, 
+  [ [ -1, -1, -1, -1, 0 ], [ 0, 0, 1, 1, 0 ], [ 1, 0, 1, 0, 0 ], 
+      [ 0, 0, -1, 0, 0 ], [ 0, 0, 0, 0, 1 ] ]^G ]
+
+gap> Size( cl[1] );
+1
+
+gap> G := SpaceGroupBBNWZ( 4, 29, 7, 2, 1 );
+SpaceGroupOnRightBBNWZ( 4, 29, 7, 2, 1 )
+
+gap> H := MaximalSubgroupRepsTG( G )[4];
+<matrix group with 7 generators>
+
+gap> C := ColorGroup( G, H );
+<matrix group with 8 generators>
+
+gap> ColorPermGroup( C );
+Group([ (2,4)(3,8)(5,6), (2,5,6,4)(3,7,8,9), (1,2,6)(3,7,5)(4,9,8), (1,3,8)
+(2,7,4)(5,9,6), (), (), (), () ])
+
+gap> P := PointGroup( C );
+<matrix group of size 72 with 4 generators>
+
+gap> IsColorGroup( P );
+true
+
+gap> G := SpaceGroupIT(3,68);
+SpaceGroupOnRightIT(3,68,'2')
+
+gap> pos := WyckoffPositions(G);
+[ < Wyckoff position, point group 3, translation := [ 0, 3/4, 1/4 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 3, translation := [ 0, 3/4, 3/4 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 6, translation := [ 0, 0, 1/2 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 6, translation := [ 1/4, 1/4, 1/2 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 2, translation := [ 1/4, 0, 0 ], 
+    basis := [ [ 0, 0, 1 ] ] >
+    , < Wyckoff position, point group 2, translation := [ 0, 3/4, 0 ], 
+    basis := [ [ 0, 0, 1 ] ] >
+    , < Wyckoff position, point group 4, translation := [ 0, 0, 1/4 ], 
+    basis := [ [ 0, 1, 0 ] ] >
+    , < Wyckoff position, point group 5, translation := [ 1/4, 1/4, 1/4 ], 
+    basis := [ [ 1, 0, 0 ] ] >
+    , < Wyckoff position, point group 1, translation := [ 0, 0, 0 ], 
+    basis := [ [ 1/2, 1/2, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] >
+     ]
+
+gap> WyckoffStabilizer(pos[5]);
+Group(
+[ [ [ -1, 0, 0, 0 ], [ 0, -1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1/2, 0, 0, 1 ] ] ])
+
+gap> S := SpaceGroupIT(2,7);
+SpaceGroupOnRightIT(2,7,'1')
+
+gap> P := PointGroup(S);
+Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, 1 ] ] ])
+
+gap> N := NormalizerInGLnZ(P);
+Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, 1 ] ], 
+  [ [ -1, 0 ], [ 0, -1 ] ], [ [ 1, 0 ], [ 0, -1 ] ], [ [ 0, 1 ], [ 1, 0 ] ] ])
+
+gap> gen := Filtered( GeneratorsOfGroup(N), x -> not x in P );
+[ [ [ 0, 1 ], [ 1, 0 ] ] ]
+
+gap> n := AugmentedMatrix( gen[1], [1/5,1/7] );
+[ [ 0, 1, 0 ], [ 1, 0, 0 ], [ 1/5, 1/7, 1 ] ]
+
+gap> S2 := S^n;
+<matrix group with 4 generators>
+
+gap> c := ConjugatorSpaceGroupsStdSamePG( S, S2 );;
+gap> S^c=S2;
+true
+
+gap> if IsPackageMarkedForLoading( "carat", "" ) then
+>   c := ConjugatorSpaceGroupsStdSamePG( S2, S );;
+>   if not S2^c=S then
+>     Error( "Cryst: conjugator test failed" );
+>   fi;
+> fi;
+
+gap> C1 := [ [ 4, -3, 0 ], [ -3, -1, 0 ], [ 1/5, 1/7, 1 ] ];
+[ [ 4, -3, 0 ], [ -3, -1, 0 ], [ 1/5, 1/7, 1 ] ]
+
+gap> C2 := [ [ -1, 4, 0 ], [ -1, -2, 0 ], [ 1/9, 1/13, 1 ] ];
+[ [ -1, 4, 0 ], [ -1, -2, 0 ], [ 1/9, 1/13, 1 ] ]
+
+gap> S1 := S^C1; IsSpaceGroup(S1);
+<matrix group with 4 generators>
+true
+
+gap> S2 := S^C2; IsSpaceGroup(S2);
+<matrix group with 4 generators>
+true
+
+gap> C  := ConjugatorSpaceGroups( S1, S2 );;
+gap> S1^C = S2;
+true
+
+gap> S1 := AffineCrystGroupOnRight(
+> [ [ [ -1, 0, 2, 0 ], [ -2, 1, 2, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 1/2, 1 ] ], 
+>   [ [ -1, 0, 0, 0 ], [ 0, -1, 0, 0 ], [ 0, 0, -1, 0 ], [ 0, 1/2, 0, 1 ] ], 
+>   [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 0, 0, 1 ] ], 
+>   [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 1 ] ], 
+>   [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 1 ] ] ] ); 
+<matrix group with 5 generators>
+gap> 
+gap> S2 := AffineCrystGroupOnRight(
+> [ [ [ -1, 0, 0, 0 ], [ 0, -1, 0, 0 ], [ 0, 0, -1, 0 ], [ 0, 0, 0, 1 ] ], 
+>   [ [ 1, 0, -2, 0 ], [ 2, -1, -2, 0 ], [ 0, 0, -1, 0 ], [ 0, 1/2, 0, 1 ] ], 
+>   [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, -1, 0, 1 ] ], 
+>   [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 0, -1, 1 ] ], 
+>   [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ -1, 1, 1, 1 ] ] ] );
+<matrix group with 5 generators>
+
+gap> if IsPackageMarkedForLoading( "carat", "" ) then
+>     c1 := ConjugatorSpaceGroups(S1,S2);;
+>     c2 := ConjugatorSpaceGroups(S2,S1);;
+>     if not ( S1^c1 = S2 and S2^c2 = S1 ) then
+>         Error( "Cryst: conjugator test 2 failed" );
+>     fi;
+> fi;
+
+gap> G := SpaceGroupIT(3, 214);;
+gap> iso := IsomorphismPcpGroup(G);;
+gap> H := Image(iso);;
+gap> h := Cgs(H)[1];;
+gap> g := PreImage(iso, h);;
+gap> h = Image(iso, g);
+true
+gap> IsomorphismPcpGroup( PointGroup( G ) );;
+
+gap> gen := GeneratorsOfGroup( SpaceGroupIT(3,149) ){[1..3]};;
+gap> Gr := AffineCrystGroup( gen );
+<matrix group with 3 generators>
+gap> Gr = AsAffineCrystGroup( Group( gen ) );
+true
+gap> TranslationBasis( Gr );
+[ [ 1, 0, 0 ], [ 0, 1, 0 ] ]
+gap> InternalBasis( Gr );
+[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
+gap> CheckTranslationBasis( Gr );
+gap> StandardAffineCrystGroup( Gr );
+<matrix group with 3 generators>
+gap> TransParts( Gr );
+[ [ 0, 0, 0 ], [ 0, 0, 0 ] ]
+gap> PointHomomorphism( Gr );
+[ [ [ 0, 1, 0, 0 ], [ -1, -1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], 
+  [ [ 0, -1, 0, 0 ], [ -1, 0, 0, 0 ], [ 0, 0, -1, 0 ], [ 0, 0, 0, 1 ] ], 
+  [ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 0, 0, 1 ] ] ] -> 
+[ [ [ 0, 1, 0 ], [ -1, -1, 0 ], [ 0, 0, 1 ] ], 
+  [ [ 0, -1, 0 ], [ -1, 0, 0 ], [ 0, 0, -1 ] ], 
+  [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ]
+
+gap> Gl := AffineCrystGroupOnLeft( List( gen, TransposedMat ) );
+<matrix group with 3 generators>
+gap> Gl = AsAffineCrystGroupOnLeft( Group( List( gen, TransposedMat ) ) );
+true
+gap> TranslationBasis( Gl );
+[ [ 1, 0, 0 ], [ 0, 1, 0 ] ]
+gap> InternalBasis( Gl );
+[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
+gap> CheckTranslationBasis( Gl );
+gap> StandardAffineCrystGroup( Gl );
+<matrix group with 3 generators>
+gap> TransParts( Gl );
+[ [ 0, 0, 0 ], [ 0, 0, 0 ] ]
+gap> PointHomomorphism( Gl );
+[ [ [ 0, -1, 0, 0 ], [ 1, -1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ], 
+  [ [ 0, -1, 0, 0 ], [ -1, 0, 0, 0 ], [ 0, 0, -1, 0 ], [ 0, 0, 0, 1 ] ], 
+  [ [ 1, 0, 0, 1 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ] ] -> 
+[ [ [ 0, -1, 0 ], [ 1, -1, 0 ], [ 0, 0, 1 ] ], 
+  [ [ 0, -1, 0 ], [ -1, 0, 0 ], [ 0, 0, -1 ] ], 
+  [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ] ]
+
+gap> SpaceGroupIT(3,213) < SpaceGroupIT(3,217);
+false
+
+gap> G := SpaceGroupIT(3,183);;
+gap> W := WyckoffPositions(G);;
+gap> C := [ [ 3, 1, 0, 0 ], [ -1, -2, 0, 0 ], [ 2, 0, 1, 0 ], [ 0, 0, 0, 1 ] ];;
+gap> IsSpaceGroup( G^C );
+true
+
+gap> G := TransposedMatrixGroup( G );
+<matrix group with 6 generators>
+gap> W := WyckoffPositions(G);;
+gap> IsSpaceGroup( G^TransposedMat(C) );
+true
+
+gap> G := SpaceGroupIT( 3, 208 );
+SpaceGroupOnRightIT(3,208,'1')
+gap> M := MaximalSubgroupClassReps( G, rec( primes := [2,3] ) );
+[ <matrix group with 7 generators>, <matrix group with 6 generators>, 
+  <matrix group with 7 generators>, <matrix group with 7 generators>, 
+  <matrix group with 5 generators>, <matrix group with 7 generators>, 
+  <matrix group with 6 generators>, <matrix group with 7 generators> ]
+gap> List( M, x -> Index( G, x ) );
+[ 2, 2, 2, 4, 4, 4, 3, 27 ]
+gap> List( Cartesian(M{[2,3,5]},M{[4,7,8]}),
+> x -> Index( G, Intersection2(x[1],x[2]) ) );
+[ 8, 6, 54, 8, 6, 54, 16, 12, 108 ]
+gap> gen := GeneratorsOfGroup( M[1] );;
+gap> Centralizer( M[1], gen[1] );
+<matrix group with 3 generators>
+gap> Centralizer( M[1], Subgroup( M[1], gen{[3]} ) );
+<matrix group with 3 generators>
+gap> C := RightCosets( G, M[3] );
+[ RightCoset(<group with 7 generators>,[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ],
+    [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]), 
+  RightCoset(<group with 7 generators>,[ [ 0, 1, 0, 0 ], [ 1, 0, 0, 0 ],
+    [ 0, 0, -1, 0 ], [ 1/2, 1/2, 1/2, 1 ] ]) ]
+gap> CanonicalRightCosetElement( M[3], Representative(C[2]) );
+[ [ -1, 0, 0, 0 ], [ 0, -1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 1, 1 ] ]
+gap>  List( M, TranslationNormalizer );
+[ <matrix group with 3 generators>, <matrix group with 3 generators>, 
+  <matrix group with 3 generators>, <matrix group with 3 generators>, 
+  <matrix group with 3 generators>, <matrix group with 3 generators>, 
+  <matrix group with 3 generators>, <matrix group with 3 generators> ]
+gap> if IsPackageMarkedForLoading( "carat", "" ) then
+>   List( M, AffineNormalizer );;
+> fi;
+gap> List( M{[2,5,7]}, x -> Orbit( G, x, OnPoints ) );;
+gap> List( M{[3,6]}, x -> OrbitStabilizer( G, x, OnPoints ) );;
+gap> List( M, x -> IsomorphismPcpGroup( PointGroup(x) ) );;
+
+gap> G := SpaceGroupOnLeftIT( 3, 208 );
+SpaceGroupOnLeftIT(3,208,'1')
+gap> M := MaximalSubgroupClassReps( G, rec( primes := [2,3] ) );
+[ <matrix group with 7 generators>, <matrix group with 6 generators>, 
+  <matrix group with 7 generators>, <matrix group with 7 generators>, 
+  <matrix group with 5 generators>, <matrix group with 7 generators>, 
+  <matrix group with 6 generators>, <matrix group with 7 generators> ]
+gap> List( M, x -> Index( G, x ) );
+[ 2, 2, 2, 4, 4, 4, 3, 27 ]
+gap> List( Cartesian(M{[4,6,7]},M{[2,5,8]}),
+> x -> Index( G, Intersection2(x[1],x[2]) ) );
+[ 8, 16, 108, 8, 16, 108, 6, 12, 81 ]
+gap> gen := GeneratorsOfGroup( M[1] );;
+gap> Centralizer( M[1], gen[1] );
+<matrix group with 3 generators>
+gap> Centralizer( M[1], Subgroup( M[1], gen{[3]} ) );
+<matrix group with 3 generators>
+gap> C := RightCosets( G, M[3] );
+[ RightCoset(<group with 7 generators>,[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ],
+    [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]), 
+  RightCoset(<group with 7 generators>,[ [ 0, 1, 0, 1/2 ], [ 1, 0, 0,
+    1/2 ], [ 0, 0, -1, 1/2 ], [ 0, 0, 0, 1 ] ]) ]
+gap> CanonicalRightCosetElement( M[3], Representative(C[2]) );
+[ [ -1, 0, 0, 0 ], [ 0, -1, 0, 0 ], [ 0, 0, 1, 1 ], [ 0, 0, 0, 1 ] ]
+gap>  List( M, TranslationNormalizer );
+[ <matrix group with 3 generators>, <matrix group with 3 generators>, 
+  <matrix group with 3 generators>, <matrix group with 3 generators>, 
+  <matrix group with 3 generators>, <matrix group with 3 generators>, 
+  <matrix group with 3 generators>, <matrix group with 3 generators> ]
+gap> if IsPackageMarkedForLoading( "carat", "" ) then
+>   List( M, AffineNormalizer );;
+> fi;
+gap> List( M{[3,7]}, x -> Orbit( G, x, OnPoints ) );;
+gap> List( M{[5,6]}, x -> OrbitStabilizer( G, x, OnPoints ) );;
+gap> List( M, x -> IsomorphismPcpGroup( PointGroup(x) ) );;
+
+gap> G := SpaceGroupOnRightIT( 3, 214 );;
+gap> K := Kernel( PointHomomorphism( G ) );
+<matrix group with 3 generators>
+gap> NaturalHomomorphismByNormalSubgroup( G, K );;
+
+gap> G := SpaceGroupOnLeftIT( 3, 222 );;
+gap> K := Kernel( PointHomomorphism( G ) );
+<matrix group with 3 generators>
+gap> NaturalHomomorphismByNormalSubgroup( G, K );;
+
+gap> G := SpaceGroupOnRightIT( 3, 222 );;
+gap> C := ConjugacyClassesMaximalSubgroups( G, rec(primes:=[2,3,5] ) );;
+gap> List( C, Size );
+[ 1, 1, 1, 4, 3, 27, 125 ]
+gap> List( C{[1..6]}, x -> Length( AsList(x) ) );
+[ 1, 1, 1, 4, 3, 27 ]
+gap> L := AsList( C[5] );
+[ <matrix group with 7 generators>, <matrix group with 7 generators>, 
+  <matrix group with 7 generators> ]
+gap> List(L, x -> RepresentativeAction( G, L[1], x, OnPoints ) );;
+gap> List( C, x -> Normalizer( G, Representative(x) ) );;
+
+gap> G := SpaceGroupOnLeftIT( 3, 222 );;
+gap> C := ConjugacyClassesMaximalSubgroups( G, rec(primes:=[2,3,5] ) );;
+gap> List( C, Size );
+[ 1, 1, 1, 4, 3, 27, 125 ]
+gap> List( C{[1..6]}, x -> Length( AsList(x) ) );
+[ 1, 1, 1, 4, 3, 27 ]
+gap> L := AsList( C[5] );
+[ <matrix group with 7 generators>, <matrix group with 7 generators>, 
+  <matrix group with 7 generators> ]
+gap> List(L, x -> RepresentativeAction( G, L[1], x, OnPoints ) );;
+gap> List( C, x -> Normalizer( G, Representative(x) ) );;
+
+gap> STOP_TEST( "cryst.tst", 10000 );
diff -urN a/cryst/tst/manual.tst b/cryst/tst/manual.tst
--- a/cryst/tst/manual.tst	1969-12-31 19:00:00.000000000 -0500
+++ b/cryst/tst/manual.tst	2018-11-01 18:56:12.000000000 -0400
@@ -0,0 +1,205 @@
+gap> START_TEST( "Cryst: manual.tst" );
+
+gap> SetAssertionLevel(1);
+
+gap> S := SpaceGroupIT(3,222);
+SpaceGroupOnRightIT(3,222,'2')
+
+gap> L := MaximalSubgroupClassReps( S, rec( primes := [3,5] ) );
+[ <matrix group with 7 generators>, <matrix group with 8 generators>, 
+  <matrix group with 8 generators> ]
+
+gap> List( L, IndexInParent );
+[ 3, 27, 125 ]
+
+gap> L := MaximalSubgroupClassReps( S,             
+>                  rec( classequal := true, primes := [3,5] ) );
+[ <matrix group with 8 generators>, <matrix group with 8 generators> ]
+
+gap> List( L, IndexInParent );                                                 
+[ 27, 125 ]
+
+gap> L := MaximalSubgroupClassReps( S,
+>                  rec( latticeequal := true, primes := [3,5] ) );
+[ <matrix group with 7 generators> ]
+
+gap> List( L, IndexInParent );                                       
+[ 3 ]
+
+gap> L := MaximalSubgroupClassReps( S, rec( latticeequal := true ) );
+[ <matrix group with 7 generators>, <matrix group with 7 generators>, 
+  <matrix group with 7 generators>, <matrix group with 7 generators>, 
+  <matrix group with 6 generators> ]
+
+gap> List( L, IndexInParent );                                       
+[ 2, 2, 2, 3, 4 ]
+
+gap> P := Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, 1 ] ] ]);
+Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, 1 ] ] ])
+
+gap> norm := [ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, 1 ] ], [ [ -1, 0 ],
+>           [ 0, -1 ] ], [ [ 1, 0 ], [ 0, -1 ] ], [ [ 0, 1 ], [ 1, 0 ] ] ];
+[ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, 1 ] ], [ [ -1, 0 ], [ 0, -1 ] ],
+  [ [ 1, 0 ], [ 0, -1 ] ], [ [ 0, 1 ], [ 1, 0 ] ] ]
+
+gap> if IsPackageMarkedForLoading( "carat", "" ) then
+>   if not norm = GeneratorsOfGroup( NormalizerInGLnZ( P ) ) then
+>     Error( "Cryst: NormalizerInGLnZ failed" );
+>   fi;
+> fi;
+
+gap> SpaceGroupsByPointGroupOnRight( P );
+[ <matrix group with 4 generators>, <matrix group with 4 generators>, 
+  <matrix group with 4 generators>, <matrix group with 4 generators> ]
+
+gap> SpaceGroupsByPointGroupOnRight( P, norm );
+[ <matrix group with 4 generators>, <matrix group with 4 generators>, 
+  <matrix group with 4 generators> ]
+
+gap> SpaceGroupsByPointGroupOnRight( P, norm, true );
+[ [ <matrix group with 4 generators> ], 
+  [ <matrix group with 4 generators>, <matrix group with 4 generators> ], 
+  [ <matrix group with 4 generators> ] ]
+  
+gap> if IsPackageMarkedForLoading( "carat", "" ) then
+>   if not ( 3 = Length( SpaceGroupTypesByPointGroupOnRight( P ) ) and
+>     [1,2,1] = List( SpaceGroupTypesByPointGroupOnRight( P, true ), Length ) )
+>   then
+>     Error( "Cryst: NormalizerInGLnZ failed" );
+>   fi;
+> fi;
+
+gap> S := SpaceGroupIT(2,14);
+SpaceGroupOnRightIT(2,14,'1')
+
+gap> W := WyckoffPositions(S);
+[ < Wyckoff position, point group 3, translation := [ 0, 0 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 3, translation := [ 2/3, 1/3 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 3, translation := [ 1/3, 2/3 ], 
+    basis := [  ] >
+    , < Wyckoff position, point group 2, translation := [ 0, 0 ], 
+    basis := [ [ 1, -1 ] ] >
+    , < Wyckoff position, point group 1, translation := [ 0, 0 ], 
+    basis := [ [ 1, 0 ], [ 0, 1 ] ] >
+     ]
+
+gap> sub := Group([ [ [ 0, -1 ], [ -1, 0 ] ] ]);
+Group([ [ [ 0, -1 ], [ -1, 0 ] ] ])
+
+gap> IsSubgroup( PointGroup( S ), sub );
+true
+
+gap> WyckoffPositionsByStabilizer( S, sub );
+[ < Wyckoff position, point group 1, translation := [ 0, 0 ], 
+    basis := [ [ 1, -1 ] ] >
+     ]
+
+gap> ForAll( W, IsWyckoffPosition );
+true
+
+gap> WyckoffBasis( W[4] );
+[ [ 1, -1 ] ]
+
+gap> WyckoffTranslation( W[3] );
+[ 1/3, 2/3 ]
+
+gap> WyckoffSpaceGroup( W[1] );
+SpaceGroupOnRightIT(2,14,'1')
+
+gap> stab := WyckoffStabilizer( W[4] );
+Group([ [ [ 0, -1, 0 ], [ -1, 0, 0 ], [ 0, 0, 1 ] ] ])
+
+gap> IsAffineCrystGroupOnRight( stab );
+true
+
+gap> orb := WyckoffOrbit( W[4] );
+[ < Wyckoff position, point group 2, translation := [ 0, 0 ], 
+    basis := [ [ 1, -1 ] ] >
+    , < Wyckoff position, point group 2, translation := [ 0, 0 ], 
+    basis := [ [ 1, 2 ] ] >
+    , < Wyckoff position, point group 2, translation := [ 0, 0 ], 
+    basis := [ [ -2, -1 ] ] >
+     ]
+gap> Set(orb);
+[ < Wyckoff position, point group 2, translation := [ 0, 0 ], 
+    basis := [ [ 1, -1 ] ] >
+     ]
+
+gap> G := Group(  (1,2,3), (2,3,4) );
+Group([ (1,2,3), (2,3,4) ])
+
+gap> H := Group( (1,2,3) ); 
+Group([ (1,2,3) ])
+
+gap> C := ColorGroup( G, H );
+Group([ (1,2,3), (2,3,4) ])
+
+gap> ColorSubgroup( C ) = H;
+true
+
+gap> ColorCosetList( C );
+[ RightCoset(Group( [ (1,2,3) ] ),()), RightCoset(Group( [ (1,2,3) ] ),(1,2)
+    (3,4)), RightCoset(Group( [ (1,2,3) ] ),(1,3)(2,4)), 
+  RightCoset(Group( [ (1,2,3) ] ),(1,4)(2,3)) ]
+
+gap> List( last, x -> ColorOfElement( C, Representative(x) ) );
+[ 1, 2, 3, 4 ]
+
+gap> U := Subgroup( C, [(1,3)(2,4)] );
+Group([ (1,3)(2,4) ])
+
+gap> IsColorGroup( U );
+true
+
+gap> ColorSubgroup( U );
+Group(())
+
+gap> ColorCosetList( U );
+[ RightCoset(Group( () ),()), RightCoset(Group( () ),(1,3)(2,4)) ]
+
+gap> List( last, x -> ColorOfElement( U, Representative(x) ) );
+[ 1, 3 ]
+
+gap> S := SpaceGroupIT( 2, 10 );                                  
+SpaceGroupOnRightIT(2,10,'1')
+
+gap> m := MaximalSubgroupClassReps( S, rec( primes := [2] ) );    
+[ <matrix group with 4 generators>, <matrix group with 3 generators>, 
+  <matrix group with 4 generators> ]
+
+gap> List( last, x -> TranslationBasis(x) = TranslationBasis(S) );
+[ false, true, false ]
+
+gap> C := ColorGroup( S, m[1] );; IsColorGroup( PointGroup( C ) );
+false
+
+gap> C := ColorGroup( S, m[2] );; IsColorGroup( PointGroup( C ) );
+true
+
+gap> sub := MaximalSubgroupClassReps( S, rec( primes := [2] ) );
+[ <matrix group with 4 generators>, <matrix group with 3 generators>, 
+  <matrix group with 4 generators> ]
+
+gap> List( sub, Size );
+[ infinity, infinity, infinity ]
+
+gap> sub := Filtered( sub, s -> IndexInParent( s ) = 2 );
+[ <matrix group of size infinity with 4 generators>, 
+  <matrix group of size infinity with 3 generators>, 
+  <matrix group of size infinity with 4 generators> ]
+
+gap> Length( AffineInequivalentSubgroups( S, sub ) );
+2
+
+gap> SpaceGroupSettingsIT( 3, 146 );
+"hr"
+
+gap> SpaceGroupOnRightIT( 3, 146 );        
+SpaceGroupOnRightIT(3,146,'h')
+
+gap> SpaceGroupOnRightIT( 3, 146, 'r' );
+SpaceGroupOnRightIT(3,146,'r')
+
+gap> STOP_TEST( "manual.tst", 10000 );
diff -urN a/cryst/tst/subgrp.tst b/cryst/tst/subgrp.tst
--- a/cryst/tst/subgrp.tst	1969-12-31 19:00:00.000000000 -0500
+++ b/cryst/tst/subgrp.tst	2018-11-01 18:56:12.000000000 -0400
@@ -0,0 +1,45 @@
+gap> START_TEST( "Cryst: subgrp.tst" );
+
+gap> SetAssertionLevel(1);
+
+gap> le := rec( latticeequal := true );
+rec( latticeequal := true )
+
+gap> ce := rec( classequal := true, primes := [2,3,5] );
+rec( classequal := true, primes := [ 2, 3, 5 ] )
+
+gap> so := rec( primes := [2,3,5] );
+rec( primes := [ 2, 3, 5 ] )
+
+gap> l1 := List( [1..17], i -> Length( MaximalSubgroupClassReps(
+>                     SpaceGroupIT( 2, i ), le ) ) );
+[ 0, 1, 1, 1, 1, 3, 3, 3, 3, 1, 3, 3, 1, 2, 2, 2, 4 ]
+
+gap> l2 := List( [1..17], i -> Length( MaximalSubgroupClassReps(
+>                     SpaceGroupIT( 2, i ), ce ) ) );
+[ 13, 16, 10, 6, 6, 16, 8, 4, 8, 5, 6, 2, 5, 5, 3, 3, 3 ]
+
+gap> l3 := List( [1..17], i -> Length( MaximalSubgroupClassReps(
+>                     SpaceGroupIT( 2, i ), so ) ) );
+[ 13, 17, 11, 7, 7, 19, 11, 7, 11, 6, 9, 5, 6, 7, 5, 5, 7 ]
+
+gap> l1 + l2 = l3;
+true
+
+gap> l1 := List( [1..23], i -> Length( MaximalSubgroupClassReps(
+>                     SpaceGroupIT( 3, 10*i ), le ) ) );
+[ 3, 3, 3, 3, 7, 7, 7, 1, 3, 3, 3, 3, 7, 7, 2, 2, 2, 4, 4, 3, 3, 3, 5 ]
+
+gap> l2 := List( [1..23], i -> Length( MaximalSubgroupClassReps(
+>                     SpaceGroupIT( 3, 10*i ), ce ) ) );
+[ 40, 10, 10, 10, 14, 6, 6, 7, 8, 8, 4, 8, 4, 12, 9, 6, 4, 8, 5, 8, 4, 2, 2 ]
+
+gap> l3 := List( [1..23], i -> Length( MaximalSubgroupClassReps(
+>                     SpaceGroupIT( 3, 10*i ), so ) ) );
+[ 43, 13, 13, 13, 21, 13, 13, 8, 11, 11, 7, 11, 11, 19, 11, 8, 6, 12,
+  9, 11, 7, 5, 7 ]
+
+gap> l1 + l2 = l3;
+true
+
+gap> STOP_TEST( "subgrp.tst", 10000 );
diff -urN a/cryst/tst/testall.g b/cryst/tst/testall.g
--- a/cryst/tst/testall.g	1969-12-31 19:00:00.000000000 -0500
+++ b/cryst/tst/testall.g	2018-11-01 18:56:12.000000000 -0400
@@ -0,0 +1,8 @@
+LoadPackage( "cryst" );
+LoadPackage( "crystcat" );
+
+TestDirectory( DirectoriesPackageLibrary( "cryst", "tst" ),
+  rec( exitGAP     := true,
+       testOptions := rec( compareFunction := "uptowhitespace") ) );
+
+FORCE_QUIT_GAP(1); # if we ever get here, there was an error
diff -urN a/cryst/tst/wyckoff.tst b/cryst/tst/wyckoff.tst
--- a/cryst/tst/wyckoff.tst	1969-12-31 19:00:00.000000000 -0500
+++ b/cryst/tst/wyckoff.tst	2018-11-01 18:56:12.000000000 -0400
@@ -0,0 +1,12 @@
+gap> START_TEST( "Cryst: wyckoff.tst" );
+
+gap> SetAssertionLevel(1);
+
+gap> List( [1..17], i -> Length( WyckoffPositions( SpaceGroupIT(2,i) ) ) );
+[ 1, 5, 3, 1, 2, 9, 4, 3, 6, 4, 7, 5, 4, 5, 4, 4, 6 ]
+
+gap> List( [1..23], i -> Length( WyckoffPositions( SpaceGroupIT(3,10*i-3) ) ) );
+[ 1, 5, 5, 5, 27, 5, 15, 5, 9, 12, 5, 11, 15, 9, 7, 4, 6, 14, 15, 7, 11, 8, 
+  10 ]
+
+gap> STOP_TEST( "wyckoff.tst", 10000 );
diff -urN a/cryst/tst/zass.tst b/cryst/tst/zass.tst
--- a/cryst/tst/zass.tst	1969-12-31 19:00:00.000000000 -0500
+++ b/cryst/tst/zass.tst	2018-11-01 18:56:12.000000000 -0400
@@ -0,0 +1,13 @@
+gap> START_TEST( "Cryst: zass.tst" );
+
+gap> SetAssertionLevel(1);
+
+gap> List( List( [1..17], i -> SpaceGroupIT( 2, i ) ),
+>             g -> Length( SpaceGroupsByPointGroup( PointGroup( g ) ) ) );
+[ 1, 1, 2, 2, 2, 4, 4, 4, 4, 1, 2, 2, 1, 1, 1, 1, 1 ]
+
+gap> List( List( [1..23], i -> SpaceGroupIT( 3, 10*i-7 ) ),
+>             g -> Length( SpaceGroupsByPointGroup( PointGroup( g ) ) ) );
+[ 2, 8, 8, 16, 16, 64, 64, 64, 4, 8, 8, 4, 16, 16, 3, 3, 2, 6, 4, 4, 4, 4, 4 ]
+
+gap> STOP_TEST( "zass.tst", 10000 );
